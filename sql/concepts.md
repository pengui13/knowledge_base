# Основні концепції баз даних

## Моделі організації даних

### Способи організації та зберігання даних

| Модель | Опис | Приклади |
|--------|------|----------|
| **Реляційна** | Таблиці, зв'язки через ключі | MySQL, PostgreSQL |
| **Документна** | JSON/BSON документи | MongoDB, CouchDB |
| **Ключ-значення** | Пара key:value | Redis, Memcached |
| **Графова** | Вузли та зв'язки між ними | Neo4j, Amazon Neptune |

---

## SQL (Structured Query Language)

Декларативна мова для виконання операцій над даними в реляційних базах.

Основні категорії команд:
- **DDL** (Data Definition Language): CREATE, ALTER, DROP
- **DML** (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
- **DCL** (Data Control Language): GRANT, REVOKE

---

## Транзакція

Група операцій, які виконуються як одне ціле — атомарно.

**Приклад банківського переказу:**
```sql
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 'A';
  UPDATE accounts SET balance = balance + 100 WHERE id = 'B';
COMMIT;
```

Результат: або обидві операції виконані успішно, або жодна (rollback).

---

## ACID властивості транзакцій

| Властивість | Опис | Приклад |
|-------------|------|---------|
| **A — Atomicity** (Атомарність) | Всі операції виконуються повністю або жодна | Переказ грошей: або списали і зарахували, або нічого |
| **C — Consistency** (Узгодженість) | Дані залишаються валідними до і після транзакції | Сума грошей у системі не змінюється після переказу |
| **I — Isolation** (Ізольованість) | Транзакції не бачать незавершені зміни одна одної | Паралельні транзакції працюють незалежно |
| **D — Durability** (Довговічність) | Після COMMIT зміни зберігаються назавжди | Навіть при збої сервера дані не втрачаються |

---

## Індекси

Структури даних для прискорення пошуку в таблицях.

### Без індексу vs З індексом

```sql
-- Без індексу: повний перебір (Full Table Scan)
SELECT * FROM users WHERE email = 'test@gmail.com';
-- Час: ~2 секунди (перебір 1 млн рядків)

-- Створення індексу
CREATE INDEX idx_email ON users(email);

-- З індексом: швидкий пошук через дерево
SELECT * FROM users WHERE email = 'test@gmail.com';
-- Час: ~0.001 секунди
```

---

### Типи індексів

#### 1. B-Tree (Balanced Tree)

Збалансоване дерево — стандартний і найпоширеніший тип індексу.

**Структура:**
```
         [M]
        /   \
     [D,H]  [R,W]
     / | \   / | \
   A-C D-G H-K R-V W-Z
```

**Підтримує операції:**
- Точний пошук: `=`
- Порівняння: `>`, `<`, `>=`, `<=`
- Діапазони: `BETWEEN`
- Сортування: `ORDER BY`
- Префіксний пошук: `LIKE 'abc%'`

**Приклад:**
```sql
CREATE INDEX idx_age ON users(age);
SELECT * FROM users WHERE age BETWEEN 18 AND 25;
-- B-Tree швидко знаходить діапазон значень
```

---

#### 2. Hash індекс

Хеш-таблиця для надшвидкого пошуку за точним значенням.

**Принцип роботи:**
```
email = "test@gmail.com"
      ↓
   hash()
      ↓
  bucket #7 → рядок #17
```

**Підтримує:** тільки `=`

**НЕ підтримує:** `>`, `<`, `BETWEEN`, `LIKE`, `ORDER BY`

**Ідеально для:**
- Session ID
- UUID
- Токени аутентифікації

---

#### 3. Full-Text індекс

Спеціалізований індекс для пошуку слів у текстових полях.

**Чому B-Tree не підходить:**
```sql
-- LIKE '%database%' — повний перебір, індекс не допоможе
SELECT * FROM articles WHERE content LIKE '%database%';
```

**Full-Text рішення:**
```sql
CREATE FULLTEXT INDEX idx_content ON articles(content);
SELECT * FROM articles 
WHERE MATCH(content) AGAINST('database technology');
```

**Переваги:**
- Швидкий пошук слів у великих текстах
- Ігнорує стоп-слова ("the", "a", "is")
- Розуміє морфологію (run → running, ran)
- Ранжування за релевантністю

---

### Коли використовувати який індекс

| Сценарій | Тип індексу |
|----------|-------------|
| Пошук за точним значенням + діапазони + сортування | **B-Tree** |
| Тільки точний пошук (session, UUID) | **Hash** |
| Пошук слів у тексті (статті, коментарі) | **Full-Text** |
| Геолокаційні дані | **Spatial (R-Tree)** |

---

## Backup стратегії

### Типи резервного копіювання

| Тип | Опис | Приклад (тиждень) |
|-----|------|-------------------|
| **Full** | Повна копія всієї БД | Нд: 100 ГБ |
| **Incremental** | Тільки зміни з останнього backup (будь-якого) | Пн: 50 МБ, Вт: 30 МБ, Ср: 40 МБ |
| **Differential** | Всі зміни з останнього FULL backup | Пн: 50 МБ, Вт: 80 МБ, Ср: 120 МБ |

**Порівняння:**

```
Full (Нд) ─────────────────────────────────────→
           │
Incremental:  Пн(+50) → Вт(+30) → Ср(+40)
              зміни     зміни     зміни
              з Нд      з Пн      з Вт

Differential: Пн(+50) → Вт(+80) → Ср(+120)
              зміни     зміни     зміни
              з Нд      з Нд      з Нд
```

**Відновлення:**
- Incremental: Full + всі incremental по черзі
- Differential: Full + останній differential

---

## Розподілені бази даних

Дані розміщені на кількох серверах.

### Навіщо розподіляти?

1. **Масштабування** — більше даних, ніж вміщує один сервер
2. **Відмовостійкість** — один сервер впав, інші працюють
3. **Швидкість** — сервер ближче до користувача (geo-distributed)

---

### Шардінг (Sharding)

Горизонтальний розподіл даних між серверами.

```
┌─────────────────┐    ┌─────────────────┐
│   Shard 1       │    │   Shard 2       │
│   Users A-M     │    │   Users N-Z     │
│   500K records  │    │   500K records  │
└─────────────────┘    └─────────────────┘
```

**Стратегії шардінгу:**
- **Range-based:** За діапазоном (A-M, N-Z)
- **Hash-based:** hash(user_id) % num_shards
- **Directory-based:** Lookup таблиця

---

### Реплікація (Replication)

Копіювання даних на кілька серверів.

**Master-Slave (Primary-Replica):**
```
     ┌─────────┐
     │ Master  │ ←── Всі WRITE операції
     │  (RW)   │
     └────┬────┘
          │ реплікація
    ┌─────┴─────┐
    ↓           ↓
┌───────┐   ┌───────┐
│ Slave │   │ Slave │ ←── READ операції
│  (R)  │   │  (R)  │
└───────┘   └───────┘
```

**Master-Master:**
```
┌─────────┐ ←──────→ ┌─────────┐
│ Master  │  sync    │ Master  │
│  (RW)   │          │  (RW)   │
└─────────┘          └─────────┘
```

**Компроміси:** Конфлікти при одночасному записі в обидва master.

---

## CAP теорема

У розподіленій системі можна гарантувати лише 2 з 3 властивостей:

- **C — Consistency:** Всі вузли бачать однакові дані
- **A — Availability:** Система завжди відповідає
- **P — Partition Tolerance:** Система працює при розриві мережі

```
        C
       /\
      /  \
    CA    CP
    /      \
   A ────── P
       AP
```

| Тип | Приклади | Опис |
|-----|----------|------|
| **CP** | MongoDB, Redis Cluster | Консистентність важливіша за доступність |
| **AP** | Cassandra, DynamoDB | Доступність важливіша за консистентність |
| **CA** | PostgreSQL (single node) | Немає partition tolerance |

---

## Безпека даних

| Механізм | Опис |
|----------|------|
| **Аутентифікація** | Перевірка особи (логін/пароль, сертифікати) |
| **Авторизація** | Перевірка прав доступу (GRANT, REVOKE) |
| **Шифрування at rest** | Дані зашифровані на диску (TDE) |
| **Шифрування in transit** | SSL/TLS для з'єднань |
| **SQL Injection захист** | Параметризовані запити (prepared statements) |

**Приклад SQL Injection захисту:**
```python
# ❌ Вразливо
query = f"SELECT * FROM users WHERE email = '{email}'"

# ✅ Безпечно (параметризований запит)
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
```

---

## Рівні ізоляції транзакцій

| Рівень | Dirty Read | Non-repeatable Read | Phantom Read |
|--------|------------|---------------------|--------------|
| READ UNCOMMITTED | ✓ можливий | ✓ можливий | ✓ можливий |
| READ COMMITTED | ✗ | ✓ можливий | ✓ можливий |
| REPEATABLE READ | ✗ | ✗ | ✓ можливий |
| SERIALIZABLE | ✗ | ✗ | ✗ |

**Пояснення проблем:**
- **Dirty Read:** Читання незакомічених змін іншої транзакції
- **Non-repeatable Read:** Повторне читання дає інший результат
- **Phantom Read:** З'являються нові рядки при повторному запиті

---

## Нормалізація

Процес організації даних для зменшення надлишковості.

| Форма | Вимога |
|-------|--------|
| **1NF** | Атомарні значення (немає масивів у комірках) |
| **2NF** | 1NF + немає часткової залежності від складеного ключа |
| **3NF** | 2NF + немає транзитивних залежностей |
| **BCNF** | Кожен детермінант є кандидатом у ключі |

---

## Корисні команди PostgreSQL

```sql
-- Аналіз плану запиту
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@gmail.com';

-- Перегляд індексів таблиці
\di users

-- Статистика використання індексів
SELECT * FROM pg_stat_user_indexes WHERE relname = 'users';

-- Розмір таблиці та індексів
SELECT pg_size_pretty(pg_total_relation_size('users'));
```