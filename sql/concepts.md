# Основні концепції баз даних

## Моделі організації даних

| Модель | Опис | Приклади |
|--------|------|----------|
| **Реляційна** | Таблиці, зв'язки через ключі | MySQL, PostgreSQL |
| **Документна** | JSON/BSON документи | MongoDB, CouchDB |
| **Ключ-значення** | Пара key:value | Redis, Memcached |
| **Графова** | Вузли та зв'язки між ними | Neo4j, Amazon Neptune |

---

## SQL (Structured Query Language)

Декларативна мова для виконання операцій над даними в реляційних базах.

- **DDL** (Data Definition Language): CREATE, ALTER, DROP
- **DML** (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
- **DCL** (Data Control Language): GRANT, REVOKE

---

## Транзакція

Група операцій, які виконуються як одне ціле — атомарно.

```sql
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 'A';
  UPDATE accounts SET balance = balance + 100 WHERE id = 'B';
COMMIT;
```

Результат: або обидві операції виконані успішно, або жодна (rollback).

---

## ACID властивості транзакцій

| Властивість | Опис | Приклад |
|-------------|------|---------|
| **A — Atomicity** | Всі операції виконуються повністю або жодна | Переказ: або списали і зарахували, або нічого |
| **C — Consistency** | Дані залишаються валідними до і після транзакції | Сума грошей у системі не змінюється |
| **I — Isolation** | Транзакції не бачать незавершені зміни одна одної | Паралельні транзакції працюють незалежно |
| **D — Durability** | Після COMMIT зміни зберігаються назавжди | Навіть при збої сервера дані не втрачаються |

---

## Індекси

Структури даних для прискорення пошуку в таблицях.

```sql
-- Без індексу: повний перебір (Full Table Scan)
SELECT * FROM users WHERE email = 'test@gmail.com';
-- Час: ~2 секунди (перебір 1 млн рядків)

-- Створення індексу
CREATE INDEX idx_email ON users(email);

-- З індексом: швидкий пошук через дерево
SELECT * FROM users WHERE email = 'test@gmail.com';
-- Час: ~0.001 секунди
```

### Типи індексів

#### B-Tree (Balanced Tree)

Збалансоване дерево — стандартний і найпоширеніший тип.

```
         [M]
        /   \
     [D,H]  [R,W]
     / | \   / | \
   A-C D-G H-K R-V W-Z
```

Підтримує: `=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `ORDER BY`, `LIKE 'abc%'`

```sql
CREATE INDEX idx_age ON users(age);
SELECT * FROM users WHERE age BETWEEN 18 AND 25;
```

#### Hash індекс

Хеш-таблиця для надшвидкого пошуку за точним значенням.

```
email = "test@gmail.com" → hash() → bucket #7 → рядок #17
```

Підтримує: тільки `=`
НЕ підтримує: `>`, `<`, `BETWEEN`, `LIKE`, `ORDER BY`

Ідеально для: Session ID, UUID, токени аутентифікації.

#### Full-Text індекс

Для пошуку слів у текстових полях.

```sql
-- LIKE '%database%' — повний перебір, B-Tree не допоможе
CREATE FULLTEXT INDEX idx_content ON articles(content);
SELECT * FROM articles WHERE MATCH(content) AGAINST('database technology');
```

Переваги: ігнорує стоп-слова, розуміє морфологію, ранжує за релевантністю.

### Коли який індекс

| Сценарій | Тип |
|----------|-----|
| Пошук + діапазони + сортування | **B-Tree** |
| Тільки точний пошук (session, UUID) | **Hash** |
| Пошук слів у тексті | **Full-Text** |
| Геолокація | **Spatial (R-Tree)** |

---

## Backup стратегії

| Тип | Опис | Приклад (тиждень) |
|-----|------|-------------------|
| **Full** | Повна копія всієї БД | Нд: 100 ГБ |
| **Incremental** | Зміни з останнього будь-якого backup | Пн: 50 МБ, Вт: 30 МБ, Ср: 40 МБ |
| **Differential** | Всі зміни з останнього FULL | Пн: 50 МБ, Вт: 80 МБ, Ср: 120 МБ |

```
Full (Нд) ──────────────────────────────────→
Incremental:  Пн(+50) → Вт(+30) → Ср(+40)
              з Нд       з Пн      з Вт

Differential: Пн(+50) → Вт(+80) → Ср(+120)
              з Нд       з Нд      з Нд
```

- **Incremental відновлення:** Full + всі incremental по черзі
- **Differential відновлення:** Full + тільки останній differential

---

## Розподілені бази даних

### Навіщо?

1. **Масштабування** — більше даних, ніж вміщує один сервер
2. **Відмовостійкість** — один сервер впав, інші працюють
3. **Швидкість** — сервер ближче до користувача

### Шардінг (Sharding)

Горизонтальний розподіл даних між серверами.

```
┌─────────────────┐    ┌─────────────────┐
│   Shard 1       │    │   Shard 2       │
│   Users A-M     │    │   Users N-Z     │
│   500K records  │    │   500K records  │
└─────────────────┘    └─────────────────┘
```

Стратегії: Range-based (A-M, N-Z), Hash-based (hash(id) % N), Directory-based.

### Реплікація (Replication)

**Master-Slave:**
```
     ┌─────────┐
     │ Master  │ ←── Всі WRITE операції
     └────┬────┘
          │ реплікація
    ┌─────┴─────┐
    ↓           ↓
┌───────┐   ┌───────┐
│ Slave │   │ Slave │ ←── READ операції
└───────┘   └───────┘
```

**Master-Master:** обидва приймають записи, але можливі конфлікти при одночасному записі.

---

## CAP теорема

У розподіленій системі можна гарантувати лише 2 з 3:

- **C — Consistency:** Всі вузли бачать однакові дані
- **A — Availability:** Система завжди відповідає
- **P — Partition Tolerance:** Система працює при розриві мережі

| Тип | Приклади | Що жертвує |
|-----|----------|------------|
| **CP** | MongoDB, Redis Cluster | Доступністю |
| **AP** | Cassandra, DynamoDB | Консистентністю |
| **CA** | PostgreSQL (single node) | Partition tolerance |

---

## Безпека даних

| Механізм | Опис |
|----------|------|
| **Аутентифікація** | Перевірка особи (логін/пароль, сертифікати) |
| **Авторизація** | Перевірка прав (GRANT, REVOKE) |
| **Шифрування at rest** | Дані зашифровані на диску (TDE) |
| **Шифрування in transit** | SSL/TLS для з'єднань |
| **SQL Injection захист** | Параметризовані запити |

```python
# ❌ Вразливо
query = f"SELECT * FROM users WHERE email = '{email}'"

# ✅ Безпечно
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
```

---

## Рівні ізоляції транзакцій

| Рівень | Dirty Read | Non-repeatable Read | Phantom Read |
|--------|------------|---------------------|--------------|
| READ UNCOMMITTED | ✓ | ✓ | ✓ |
| READ COMMITTED | ✗ | ✓ | ✓ |
| REPEATABLE READ | ✗ | ✗ | ✓ |
| SERIALIZABLE | ✗ | ✗ | ✗ |

- **Dirty Read:** читання незакомічених змін іншої транзакції
- **Non-repeatable Read:** повторне читання дає інший результат
- **Phantom Read:** з'являються нові рядки при повторному запиті

---

## Нормалізація

Процес організації даних для зменшення надлишковості та аномалій при оновленні.

---

### 1NF — Перша нормальна форма

**Правило:** Кожна комірка містить одне атомарне значення. Немає масивів, списків, повторюваних груп.

**❌ Порушення 1NF:**

| student_id | name  | courses                  |
|------------|-------|--------------------------|
| 1          | Alice | Math, Physics, Chemistry |
| 2          | Bob   | Math, History            |

Проблема: в одній комірці — кілька значень. Не можна зробити `WHERE course = 'Math'`.

**✅ 1NF:**

| student_id | name  | course    |
|------------|-------|-----------|
| 1          | Alice | Math      |
| 1          | Alice | Physics   |
| 1          | Alice | Chemistry |
| 2          | Bob   | Math      |
| 2          | Bob   | History   |

---

### 2NF — Друга нормальна форма

**Правило:** 1NF + кожен не-ключовий атрибут залежить від **всього** складеного ключа, а не від його частини.

Актуально тільки якщо є **складений первинний ключ** (з двох і більше стовпців).

**❌ Порушення 2NF:**

| student_id | course_id | student_name | course_name |
|------------|-----------|--------------|-------------|
| 1          | 101       | Alice        | Math        |
| 1          | 102       | Alice        | Physics     |
| 2          | 101       | Bob          | Math        |

PK = (student_id, course_id)

- `student_name` залежить тільки від `student_id` — часткова залежність ❌
- `course_name` залежить тільки від `course_id` — часткова залежність ❌

**✅ 2NF — розбиваємо на таблиці:**

**Students:**
| student_id | student_name |
|------------|--------------|
| 1          | Alice        |
| 2          | Bob          |

**Courses:**
| course_id | course_name |
|-----------|-------------|
| 101       | Math        |
| 102       | Physics     |

**Enrollments:**
| student_id | course_id |
|------------|-----------|
| 1          | 101       |
| 1          | 102       |
| 2          | 101       |

---

### 3NF — Третя нормальна форма

**Правило:** 2NF + немає транзитивних залежностей. Не-ключовий атрибут не повинен залежати від іншого не-ключового атрибута.

Тобто: `PK → A → B` — це порушення. B має залежати від PK напряму.

**❌ Порушення 3NF:**

| student_id | name  | zip_code | city |
|------------|-------|----------|------|
| 1          | Alice | 79000    | Lviv |
| 2          | Bob   | 01001    | Kyiv |
| 3          | Carol | 79000    | Lviv |

- `student_id → zip_code` ✅
- `zip_code → city` — транзитивна залежність ❌

`city` залежить не від `student_id`, а від `zip_code`. Якщо місто для 79000 зміниться — треба оновлювати кілька рядків.

**✅ 3NF:**

**Students:**
| student_id | name  | zip_code |
|------------|-------|----------|
| 1          | Alice | 79000    |
| 2          | Bob   | 01001    |
| 3          | Carol | 79000    |

**ZipCodes:**
| zip_code | city |
|----------|------|
| 79000    | Lviv |
| 01001    | Kyiv |

---

### BCNF — Бойс-Кодд нормальна форма

**Правило:** Посилена 3NF. Кожен детермінант (атрибут, від якого щось залежить) повинен бути кандидатним ключем.

Виникає коли є кілька перекриваючихся кандидатних ключів — рідкісний випадок.

**❌ Порушення BCNF:**

Умова: один викладач веде тільки один предмет. Студент записується до конкретного викладача.

| student_id | subject | teacher     |
|------------|---------|-------------|
| 1          | Math    | Prof. Koval |
| 2          | Math    | Prof. Koval |
| 1          | Physics | Prof. Meln  |

- `(student_id, subject)` — кандидатний ключ
- `(student_id, teacher)` — теж кандидатний ключ
- `teacher → subject` — але `teacher` сам по собі не є кандидатним ключем ❌

**✅ BCNF:**

**TeacherSubject:**
| teacher     | subject |
|-------------|---------|
| Prof. Koval | Math    |
| Prof. Meln  | Physics |

**StudentTeacher:**
| student_id | teacher     |
|------------|-------------|
| 1          | Prof. Koval |
| 2          | Prof. Koval |
| 1          | Prof. Meln  |

---

### Підсумок нормалізації

| Форма | Що усуває |
|-------|-----------|
| **1NF** | Масиви і списки в комірках |
| **2NF** | Часткові залежності від складеного ключа |
| **3NF** | Транзитивні залежності (A → B → C) |
| **BCNF** | Аномалії при кількох кандидатних ключах |

На практиці **3NF достатньо** для більшості проєктів. BCNF — рідкісний edge case.

---

## Корисні команди PostgreSQL

```sql
-- Аналіз плану запиту
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@gmail.com';

-- Перегляд індексів таблиці
\di users

-- Статистика використання індексів
SELECT * FROM pg_stat_user_indexes WHERE relname = 'users';

-- Розмір таблиці та індексів
SELECT pg_size_pretty(pg_total_relation_size('users'));
```
