# Основні концепції баз даних

## Моделі організації даних

### Способи організації та зберігання даних

Моделі:
1. Реляційна - таблиці, зв'язки і співвідношення
2. Документна - JSON/BSON документи
3. Ключ-значення - пара key:value
4. Графова - вузли і зв'язки

Приклади:
- Реляційна: MySQL, PostgreSQL
- Документна: MongoDB
- Ключ-значення: Redis
- Графова: Neo4j

```
Реляційна:                    Документна:
┌────┬───────┬─────┐          {
│ id │ name  │ age │            "id": 1,
├────┼───────┼─────┤            "name": "John",
│ 1  │ John  │ 25  │            "age": 25
│ 2  │ Anna  │ 30  │          }
└────┴───────┴─────┘

Ключ-значення:                Графова:
┌─────────────┬───────┐       (John)──[KNOWS]──>(Anna)
│ session:123 │ {...} │              │
│ user:1      │ {...} │         [WORKS_AT]
└─────────────┴───────┘              ↓
                                 (Google)
```

## SQL (Structured Query Language)

Мова для виконання операцій над даними в реляційних базах.

Основні категорії команд:
- DDL (Data Definition): CREATE, ALTER, DROP
- DML (Data Manipulation): SELECT, INSERT, UPDATE, DELETE
- DCL (Data Control): GRANT, REVOKE

## Транзакція

Група операцій, які виконуються як одне ціле.

Приклад транзакції:
1. Зняти 100 грн з рахунку А
2. Додати 100 грн на рахунок Б

Або обидві виконані, або жодна.

```
BEGIN TRANSACTION
    ├── UPDATE accounts SET balance = balance - 100 WHERE id = 'A'
    ├── UPDATE accounts SET balance = balance + 100 WHERE id = 'B'
    │
    ├── Все OK? ──→ COMMIT (зберегти)
    └── Помилка? ──→ ROLLBACK (відкотити)
```

## ACID властивості транзакцій

A - Atomicity (Атомарність)
Всі операції виконуються повністю або жодна.

C - Consistency (Консистентність)
Дані залишаються в узгодженому стані до і після транзакції.

I - Isolation (Ізольованість)
Транзакції не впливають одна на одну, незалежно виконуються. Одна транзакція не бачить незавершені зміни іншої.

D - Durability (Довговічність)
Після успішного завершення транзакції зміни зберігаються назавжди.

```
Приклад ACID (переказ 100 грн):

A: Або (-100 з А) І (+100 на Б), або нічого
C: Сума грошей до = сума грошей після (1000 = 1000)
I: Інша транзакція не бачить "половину" переказу
D: Після COMMIT навіть при збої сервера гроші не зникнуть
```

## Індекси

### Індекс (B-Tree / B+Tree)

Структура для швидкого пошуку. Працює як алфавітний покажчик у книзі — замість перегортати всі сторінки, одразу йдеш на потрібну літеру.

Без індексу:
SELECT * FROM users WHERE email = 'test@gmail.com'

Повільно: перебирає всі рядки (Full Table Scan).

З індексом:
CREATE INDEX idx_email ON users(email);

Значно швидше: O(log n) замість O(n).

### Типи індексів

#### B-Tree (Balanced Tree)

Стандартний індекс з деревом для швидкого пошуку.

Приклад структури:
```
Шукаємо значення 60:

        [50]              ← 60 > 50, йдемо вправо
       /    \
    [25]    [75]          ← 60 < 75, йдемо вліво
    /  \    /  \
  [10][30][60][90]        ← Знайшли! (3 кроки замість 7)
```

Властивості B-Tree:
- Пошук від кореня до листка (вертикальний пошук)
- Всі дані зберігаються в листках (для B+Tree)
- Послідовний обхід листків для діапазонних запитів
- Після знаходження листка — дані одразу доступні

Підтримує операції:
- =, >, <, >=, <=
- BETWEEN
- ORDER BY
- LIKE 'abc%'

#### Hash індекс

Підтримує тільки оператор рівності. Найшвидший для точного пошуку, але обмежений у функціональності.

SELECT * FROM users WHERE email = "test@gmail.com"

Принцип роботи:
```
email = "test@gmail.com"
         │
         ▼
      hash()
         │
         ▼
    bucket #7 ──→ рядок з даними

Час пошуку: O(1) - константний!
```

Підтримує: тільки =
НЕ підтримує: порівняння (>, <), LIKE, ORDER BY

#### Full-Text індекс

Для пошуку слів у тексті. Створює інвертований індекс — для кожного слова зберігає список документів, де воно зустрічається.

Навіщо: Коли потрібно знайти слово "database" всередині тексту.

SELECT * FROM articles WHERE MATCH(content) AGAINST('database');

```
Інвертований індекс:
┌───────────┬─────────────────┐
│ Слово     │ Документи       │
├───────────┼─────────────────┤
│ database  │ [1, 5, 23, 156] │
│ python    │ [2, 5, 89]      │
│ index     │ [1, 23, 45]     │
└───────────┴─────────────────┘
```

Переваги:
- Пошук слів у великому тексті
- Ігнорує стоп-слова ("the", "a", "is")
- Знаходить різні форми слова (run, running, ran)

B-Tree не підходить, бо LIKE '%database%' - повний перебір.

## Різниця між типами Backup

### Full (Повний)

Копіюємо все. Приклад: копіюємо всю БД (100 ГБ).

### Incremental (Інкрементний)

Після full backup копіюємо лише зміни з останнього backup.
- Пн: зміни з неділі (50 МБ)
- Вт: зміни з понеділка (30 МБ)

### Differential (Диференційний)

Після full backup копіюємо всі зміни з моменту full backup:
- Вт: всі зміни з неділі (100 МБ)
- Ср: всі зміни з неділі (200 МБ)

```
Нд: Full (100 ГБ)
     │
     ├── Incremental:          ├── Differential:
     │   Пн: +50 МБ (з Нд)     │   Пн: +50 МБ (з Нд)
     │   Вт: +30 МБ (з Пн)     │   Вт: +80 МБ (з Нд)
     │   Ср: +40 МБ (з Вт)     │   Ср: +120 МБ (з Нд)
     │                         │
     │   Відновлення:          │   Відновлення:
     │   Full + Пн + Вт + Ср   │   Full + Ср
     │   (складніше)           │   (простіше)
```

## Розподілені бази даних (Distributed)

Дані на кількох серверах.

Навіщо:
- Більше даних, ніж влізає на 1 сервер
- Відмовостійкість (один впав - інші працюють)
- Швидкість (сервер ближче до клієнта)

### Шардінг

Розподіл даних на кілька серверів. Кожен шард містить унікальну частину даних.

Приклад:
- Сервер 1: користувачі А-М
- Сервер 2: користувачі N-Z

```
         [Router]
         /      \
   [Shard 1]  [Shard 2]
    Users      Users
     A-M        N-Z
```

### Реплікація

Копіювання даних на кілька серверів. Кожна репліка містить повну копію даних.

Типи:
- Master-Slave: 1 пише, інші читають
- Master-Master: Всі пишуть

```
Master-Slave:                 Master-Master:
                              
   [Master]                   [Master] ←──→ [Master]
   (R + W)                     (R+W)          (R+W)
      │                        
      ├────────┐              Проблема: конфлікти
      ↓        ↓              при одночасному записі
  [Slave]  [Slave]
   (R)      (R)
```

### Безпека даних

Аутентифікація: Логін/пароль (хто ти?)
Авторизація: Права доступу (що тобі дозволено?)
Шифрування: Дані зашифровані на диску
SQL Injection захист: Параметризовані запити

```python
# ❌ Вразливо до SQL Injection:
query = f"SELECT * FROM users WHERE email = '{email}'"
# email = "'; DROP TABLE users; --"

# ✅ Безпечно:
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
```

## Приклади використання індексів

### Приклад 1: Пошук користувача за email

Без індексу:
SELECT * FROM users WHERE email = 'test@gmail.com';
Час: 2 секунди (перебір 1 млн рядків)

З індексом:
CREATE INDEX idx_email ON users(email);
SELECT * FROM users WHERE email = 'test@gmail.com';
Час: 0.001 секунди

### Приклад 2: B-Tree для діапазонів

CREATE INDEX idx_age ON users(age);
SELECT * FROM users WHERE age BETWEEN 18 AND 25;

B-Tree дозволяє швидко знайти діапазон значень.

### Приклад 3: Full-Text пошук

CREATE FULLTEXT INDEX idx_content ON articles(content);
SELECT * FROM articles WHERE MATCH(content) AGAINST('database technology');

Знаходить статті зі словами "database" або "technology".

## Коли використовувати різні типи індексів

### B-Tree - універсальний вибір
- Пошук за точним значенням
- Діапазони (BETWEEN, >, <)
- Сортування (ORDER BY)
- Префіксний пошук (LIKE 'abc%')

### Hash - тільки точний пошук
- Дуже швидкий для =
- Не працює для діапазонів
- Ідеально для session ID, UUID

### Full-Text - пошук у тексті
- Пошук слів у великих текстах
- Статті, коментарі, описи
- Розуміє морфологію слів

## OLTP vs OLAP

### OLTP - Online Transaction Processing

Онлайн обробка транзакцій

Характеристики:
- Нормалізована схема (3NF) для консистентності
- Швидкі короткі транзакції (мілісекунди)
- Багато INSERT/UPDATE/DELETE
- Тисячі одночасних користувачів

### OLAP - Online Analytical Processing

Онлайн аналітична обробка

Характеристики:
- Денормалізовано (швидкість читання важливіша)
- Майже тільки SELECT, багато JOIN
- Колонкове зберігання для швидкості читання

```
OLTP (рядкове):              OLAP (колонкове):

id | name | age | city       id:   [1, 2, 3, 4, 5...]
1  | John | 25  | Kyiv       name: [John, Anna, Max...]
2  | Anna | 30  | Lviv       age:  [25, 30, 28...]
3  | Max  | 28  | Odesa      city: [Kyiv, Lviv, Odesa...]

Швидко: один рядок           Швидко: агрегації по колонці
SELECT * WHERE id=1          SELECT AVG(age) FROM users
```

### Приклади використання

OLTP (нормалізовані, транзакційні):
- PostgreSQL, MySQL
- Банківські системи
- E-commerce

OLAP (денормалізовані, аналітичні):
- ClickHouse, BigQuery
- Data Warehouses
- Business Intelligence

Примітка: 3NF - стандарт для транзакційних БД, але для аналітики часто використовують денормалізовані схеми (Star Schema).